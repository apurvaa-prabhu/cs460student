<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS460 Assignment 5 - 3D Model Visualization</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <script src="https://mrdoob.github.io/stats.js/build/stats.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { AnaglyphEffect } from 'three/addons/effects/AnaglyphEffect.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { VertexNormalsHelper } from 'three/addons/helpers/VertexNormalsHelper.js';
        import { Pane } from 'https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.min.js';


        let scene, camera, renderer, controls, effect, stats;
        let loader, light, ambientLight;
        let pane;


        window['SCENE'] = {
            'anaglyph': false,
            'poly': null,
            'blender': null,
            'blender_helper': null,
            'rotate_poly': false,
            'do_rotate_poly': function() {
                window['SCENE']['rotate_poly'] = !window['SCENE']['rotate_poly'];
            },
            'rotate_blender': false,
            'do_rotate_blender': function() {
                window['SCENE']['rotate_blender'] = !window['SCENE']['rotate_blender'];
            },
            'blender_old_material': null,
            'change_material': function() {
                if (!window['SCENE']['blender_old_material']) {
                    window['SCENE']['blender_old_material'] = window['SCENE']['blender'].material.clone();
                    window['SCENE']['blender'].material = new THREE.MeshNormalMaterial();
                } else {
                    window['SCENE']['blender'].material = window['SCENE']['blender_old_material'].clone();
                    window['SCENE']['blender_old_material'] = null;
                }
            }
        };


        window.onload = function() {
            init();
            animate();
        };

        function init() {

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);


            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 15);


            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);


            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

        
            effect = new AnaglyphEffect(renderer);
            effect.setSize(window.innerWidth, window.innerHeight);


            light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(10, 10, 10);
            scene.add(light);

            ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);


            loader = new GLTFLoader();


            loader.load('remote1.glb', function(gltf) {
                var poly = gltf.scene.children[0];
                poly.scale.set(8, 8, 8);
                poly.quaternion.set(0, 0, 0, 1); 
                poly.position.set(10, 0, 0); 
                scene.add(poly);
                window.SCENE.poly = poly;
                

                setupPolyUI();
            });


            loader.load('remote.glb', function(gltf) {
                var blender = gltf.scene.children[0];
                blender.scale.set(8, 8, 8);
                blender.quaternion.set(0, 0, 0, 1);
                blender.position.set(-10, 0, 0); 
                scene.add(blender);
                window.SCENE.blender = blender;
                

                var helper = new VertexNormalsHelper(blender, 0.5, 'blue');
                helper.visible = false;
                scene.add(helper);
                window.SCENE.blender_helper = helper;
                

                setupBlenderUI();
            });


            stats = new Stats();
            document.body.appendChild(stats.domElement);


            setupUI();


            window.addEventListener('resize', onWindowResize);
        }

        function setupUI() {
            pane = new Pane();
            

            var sceneui = pane.addFolder({ title: 'Scene' });
            sceneui.addBinding(window.SCENE, 'anaglyph');
            sceneui.addBinding(light.position, 'x', { min: -100, max: 100, label: 'Light X' });
            sceneui.addBinding(light.position, 'y', { min: -100, max: 100, label: 'Light Y' });
            sceneui.addBinding(light.position, 'z', { min: -100, max: 100, label: 'Light Z' });
            sceneui.addBinding(light, 'intensity', { min: 0, max: 5, label: 'Light Intensity' }); // Increased to 5
            sceneui.addBinding(ambientLight, 'color', { label: 'Ambient Color' });
        }

        function setupPolyUI() {
            var polyui = pane.addFolder({ title: 'PolyCam Mesh' });
            polyui.addBinding(window.SCENE.poly.material, 'wireframe');
            polyui.addButton({ title: 'rotate!' }).on('click', () => {
                window.SCENE.do_rotate_poly();
            });
        }

        function setupBlenderUI() {
            var blenderui = pane.addFolder({ title: 'Blender Mesh' });
            blenderui.addBinding(window.SCENE.blender_helper, 'visible', { label: 'Show normals!' });
            blenderui.addButton({ title: 'Change Material!' }).on('click', () => {
                window.SCENE.change_material();
            });
            blenderui.addButton({ title: 'rotate!' }).on('click', () => {
                window.SCENE.do_rotate_blender();
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            effect.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            

            controls.update();
            

            stats.update();
            

            if (window.SCENE.poly) {
                if (window.SCENE.rotate_poly) {

                    const targetRotation = new THREE.Quaternion();
                    targetRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);
                    window.SCENE.poly.quaternion.slerp(targetRotation, 0.01);
                } else {

                    const identity = new THREE.Quaternion();
                    window.SCENE.poly.quaternion.slerp(identity, 0.01);
                }
            }
            

            if (window.SCENE.blender) {
                if (window.SCENE.rotate_blender) {
                    
                    const targetRotation = new THREE.Quaternion();
                    targetRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);
                    window.SCENE.blender.quaternion.slerp(targetRotation, 0.01);
                } else {
                    
                    const identity = new THREE.Quaternion();
                    window.SCENE.blender.quaternion.slerp(identity, 0.01);
                }
                

                if (window.SCENE.blender_helper) {
                    window.SCENE.blender_helper.update();
                }
            }
            

            if (window.SCENE.anaglyph) {
                effect.render(scene, camera);
            } else {
                renderer.render(scene, camera);
            }
        }
    </script>
</body>
</html>